{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ApplicationState ApplicationState is a simpler approach to state management. It is not opinionated, aims to be framework agnostic and has no external dependencies. There is a plugin system allowing state to be persised or otherwise processed. Why ApplicationState? Framework agnostic. Simple interface. Can work within reactive frameworks. Supports all major browsers including IE11 (via polyfills). Is extensible via a simple plugin system. Is light on external dependencies. Pre 1.0 Software ApplicationState is currently being used in production environments and it's working great. It should not present any problems so long as you stay within the same minor version. However, his software is still under active development and may involve breaking changes between minor versions. Until ApplicationState reaches 1.0 status, you should be prepared to deal with these changes if you choose to jump minor versions. We guaruntee API consistency within the same minor version. So v0.2.0 will have the same API as v0.2.1 and v0.2.2 . However, v0.3.0 may or may not introduce an API change. So long as you remain on the same minor version no breaking changes should occur. If they do please create an issue . All that said, we are pretty happy with the API as it stands, and don't have any breaking changes planned or in the works. Quick Start To use it in your project just install with npm (or yarn). 1 npm install --save applicationstate Use webpack or similar to include it as a module in your application. 1 import ApplicationState from \"applicationstate\" ; To use a persistence plugin just import that as well. 1 2 3 4 5 import ApplicationState from \"applicationstate\" ; import { init } from \"applicationstate/plugins/indexeddb\" ; init ( ApplicationState , \"database_name\" ) . then (() => {}) . catch (() => {}); Or use the local storage based plugin if you need to support IE11. 1 2 3 import ApplicationState from \"applicationstate\" ; import { init } from \"applicationstate/plugins/localstorage\" ; init ( ApplicationState , \"database_name\" ); Then get, set, and listen to your heart's content. 1 2 3 4 5 6 7 8 ApplicationState . set ( \"app.something\" , { a : \"thing\" }); const a_thing = ApplicationState . get ( \"app.something.a\" ); ApplicationState . listen ( \"app.something\" , ( new_state , previous_state ) => { // do amazing things! } );","title":"Home"},{"location":"#applicationstate","text":"ApplicationState is a simpler approach to state management. It is not opinionated, aims to be framework agnostic and has no external dependencies. There is a plugin system allowing state to be persised or otherwise processed.","title":"ApplicationState"},{"location":"#why-applicationstate","text":"Framework agnostic. Simple interface. Can work within reactive frameworks. Supports all major browsers including IE11 (via polyfills). Is extensible via a simple plugin system. Is light on external dependencies.","title":"Why ApplicationState?"},{"location":"#pre-10-software","text":"ApplicationState is currently being used in production environments and it's working great. It should not present any problems so long as you stay within the same minor version. However, his software is still under active development and may involve breaking changes between minor versions. Until ApplicationState reaches 1.0 status, you should be prepared to deal with these changes if you choose to jump minor versions. We guaruntee API consistency within the same minor version. So v0.2.0 will have the same API as v0.2.1 and v0.2.2 . However, v0.3.0 may or may not introduce an API change. So long as you remain on the same minor version no breaking changes should occur. If they do please create an issue . All that said, we are pretty happy with the API as it stands, and don't have any breaking changes planned or in the works.","title":"Pre 1.0 Software"},{"location":"#quick-start","text":"To use it in your project just install with npm (or yarn). 1 npm install --save applicationstate Use webpack or similar to include it as a module in your application. 1 import ApplicationState from \"applicationstate\" ; To use a persistence plugin just import that as well. 1 2 3 4 5 import ApplicationState from \"applicationstate\" ; import { init } from \"applicationstate/plugins/indexeddb\" ; init ( ApplicationState , \"database_name\" ) . then (() => {}) . catch (() => {}); Or use the local storage based plugin if you need to support IE11. 1 2 3 import ApplicationState from \"applicationstate\" ; import { init } from \"applicationstate/plugins/localstorage\" ; init ( ApplicationState , \"database_name\" ); Then get, set, and listen to your heart's content. 1 2 3 4 5 6 7 8 ApplicationState . set ( \"app.something\" , { a : \"thing\" }); const a_thing = ApplicationState . get ( \"app.something.a\" ); ApplicationState . listen ( \"app.something\" , ( new_state , previous_state ) => { // do amazing things! } );","title":"Quick Start"},{"location":"api/","text":"ApplicationState API The API for Application is very simple, there is currently no constructor everything is implemented statically: Methods static get(name) Argument Type Description name String The name of the desired node within the state tree. Return the value at the given path. static set(name, value) Argument Type Description name String The name of the desired node within the state tree. value Object|Array|Scalar The value to place at the specified node within the state tree. Set the value at the specified path. static listen(name, callback) Argument Type Description name String The name of the desired node to center the listener on. callback Function The function to execute when a node within the Listen for changes at the specified path, invoking the callback with the new and old values. Callback should be of the form: 1 ( new_value , old_value ) => { ... } A listener key will be returned, it can be used later to remove the listener, if needed. static removeListener(name, key) Argument Type Description name String The name of the desired node where the listener was set. key String The listener key that was returned when the listener was first set. Remove the listener at the specified path with the given key static ln(target, link_path) Argument Type Description target String The existing node to be linked. link_path String The path to create as a link. This is similar the the unix \"ln\" symlink functionality. It is used to link a node to another area in the graph. The linked node can be used interchangably with the original. Listeners will be notified on both the original path and the symlinked path. static rm(name) Argument Type Description name String The name of the node to fully remove from the state tree. Delete the specified path. If the path refers to an object or array, everything with that object or array is also removed. If the target is a symlink, only the symlink will be removed. If a node pointed to by a symlink is deleted, the symlink will also be deleted. static notify(name, explicit, options) Argument Type Description name String The name of the node to center the notification on. explicit Boolean Do not notify up or down the state tree, just notify the path specified. options Object Used by plugins. Used to trigger a listener. If explicit is set to true, only a listener that is directly pointing at the specified node will be triggered, hierarchical listeners will not. The options parameter is reserved for use by plugin authors and carries information such as whether the changed value should be persisted. static undo(name) Argument Type Description name String The name of the node to be reverted to the previous value. Revert changes to state for the specific name. Note: this honors the hierarchy, so it will navigate through all child names and undo any changes below it. So, for example, if you were to call undo('app') and 'app' was the top level key in your application, any changes to any child of app will be rewound, 'app.login', 'app.user.role' etc... If there is no previous state for the specified value, it will be set to undefined.","title":"Documentation"},{"location":"api/#applicationstate-api","text":"The API for Application is very simple, there is currently no constructor everything is implemented statically:","title":"ApplicationState API"},{"location":"api/#methods","text":"","title":"Methods"},{"location":"api/#static-getname","text":"Argument Type Description name String The name of the desired node within the state tree. Return the value at the given path.","title":"static get(name)"},{"location":"api/#static-setname-value","text":"Argument Type Description name String The name of the desired node within the state tree. value Object|Array|Scalar The value to place at the specified node within the state tree. Set the value at the specified path.","title":"static set(name, value)"},{"location":"api/#static-listenname-callback","text":"Argument Type Description name String The name of the desired node to center the listener on. callback Function The function to execute when a node within the Listen for changes at the specified path, invoking the callback with the new and old values. Callback should be of the form: 1 ( new_value , old_value ) => { ... } A listener key will be returned, it can be used later to remove the listener, if needed.","title":"static listen(name, callback)"},{"location":"api/#static-removelistenername-key","text":"Argument Type Description name String The name of the desired node where the listener was set. key String The listener key that was returned when the listener was first set. Remove the listener at the specified path with the given key","title":"static removeListener(name, key)"},{"location":"api/#static-lntarget-link_path","text":"Argument Type Description target String The existing node to be linked. link_path String The path to create as a link. This is similar the the unix \"ln\" symlink functionality. It is used to link a node to another area in the graph. The linked node can be used interchangably with the original. Listeners will be notified on both the original path and the symlinked path.","title":"static ln(target, link_path)"},{"location":"api/#static-rmname","text":"Argument Type Description name String The name of the node to fully remove from the state tree. Delete the specified path. If the path refers to an object or array, everything with that object or array is also removed. If the target is a symlink, only the symlink will be removed. If a node pointed to by a symlink is deleted, the symlink will also be deleted.","title":"static rm(name)"},{"location":"api/#static-notifyname-explicit-options","text":"Argument Type Description name String The name of the node to center the notification on. explicit Boolean Do not notify up or down the state tree, just notify the path specified. options Object Used by plugins. Used to trigger a listener. If explicit is set to true, only a listener that is directly pointing at the specified node will be triggered, hierarchical listeners will not. The options parameter is reserved for use by plugin authors and carries information such as whether the changed value should be persisted.","title":"static notify(name, explicit, options)"},{"location":"api/#static-undoname","text":"Argument Type Description name String The name of the node to be reverted to the previous value. Revert changes to state for the specific name. Note: this honors the hierarchy, so it will navigate through all child names and undo any changes below it. So, for example, if you were to call undo('app') and 'app' was the top level key in your application, any changes to any child of app will be rewound, 'app.login', 'app.user.role' etc... If there is no previous state for the specified value, it will be set to undefined.","title":"static undo(name)"},{"location":"design/","text":"Theory and Design ApplicationState, as it's name implies, is used for maintaining state in applications. It is a different approach to solving the classic problem, and is language agnostic though this implementation is in JavaScript. Over the years many patterns have emerged in software architecture - all trying to solve the same fundamental problem: maintain state, and react to changes in state. Even the simplest \"hello world\" application can be thought of in these terms: 1 2 let message = \"hello, world!\" ; console . log ( message ); In this case, we're declaring an inital state - i.e. setting some data region in memory to \"hello, world!\", and then subsequently changing the state of the user's command line by emitting the message. As applications become larger state management becomes more complex. Over the years there have been many formal and informal approaches to solving the state problem, some examples are MVC, MVP, MVVM, Reactive, etc... the definitions get fuzzy at times and overlap, but they all have one thing in common - there's some sort of state that's maintained and changes to that state cause the application to change somehow. There are advantages and disadvantages to each approach, theories of code decoupling, event driven approaches, etc... Instead of discrete models, ApplicationState recogizes that the entire state of any application can be represented as a directed acyclic graph, where each node in the graph itentifies some part of the application and each leaf contains a discrete value. (Actually, nodes can be pointers to other nodes, but this is a convenience sugaring covered in advanced topics). Here's a simple example. Imagine an application that has a simple login form, a list of jobs, and a screen that can be used to view or edit a job. Here's a rough graph of what the overall state of that application might look like: In the above graph, the root node is \"app\", with a leaf called \"location\" and three child nodes, \"user\",\"screen\" and \"current_job\". Under the user node we have some leaves with values for things like username and access_token, under \"screen\" we have \"login\", \"job_list\" and \"job_view_edit\", etc... Using the above graph, any part of the application state can be represented using simple dotted notation. For example: 1 2 3 app . location app . screen . login . username app . user . access_token With application state, this is how you both set and retrieve values. At this point, it's natural to wonder what value this approach takes above a simple object that can be represented in any language. That brings us to the second part of the ApplicationState theory, which is responding to changes. Imagine that you need to validate that a username is valid after a user has entered it. Using ApplicationState, you'd add a listener to app.screen.login.username to be notified of the change, run the validation and mutate the UI in response. Followers of reactive application flow will be very familiar with this approach. One of the advantages to the ApplicationState approach, however, is the ability to add a listener to any node or leaf in the graph and to be notified of changes that have occurred in the subgraph. For example, maybe your application would like to keep a log of all changes that occurred when a job was being edited. Adding a listener to app.screen.job_view_edit would accomplish this trivially. The key architectural insight of ApplicationState is that ALL of your UI state is represented by the graph and can be instantly stored and retrieved. This is particularly useful, for example, in mobile applications where the application can be killed and restarted at any time, and the expectation is that state will be restored properly. In the BARE architecture repo , there is documentation about how ApplicationState can fit into an overall reactive architecture, though it should be noted that ApplicationState is not limited to BARE and can be used easily with React, React Native, etc... This is a brief summary of the ApplicationState theory, there is a lot more to it with tons of handy featues like: Previous state / undo Linked nodes Plugins for persistence, loading and additional functionality (see applicationstate-plugins-indexeddb for persistence and loading from IndexedDB in the browser) Notification control Future features will include: Isomorphism plugin - automatic sync to the server Merkle tree implementation for auto change detection/tree syncing Sub graph splitting and merging Cloud functions that respond to listeners/changes using AWS lambda, Google cloud functions, etc... Once the above features are implemented, many applications will be able to full implemented \"serverless\"","title":"Theory and Design"},{"location":"design/#theory-and-design","text":"ApplicationState, as it's name implies, is used for maintaining state in applications. It is a different approach to solving the classic problem, and is language agnostic though this implementation is in JavaScript. Over the years many patterns have emerged in software architecture - all trying to solve the same fundamental problem: maintain state, and react to changes in state. Even the simplest \"hello world\" application can be thought of in these terms: 1 2 let message = \"hello, world!\" ; console . log ( message ); In this case, we're declaring an inital state - i.e. setting some data region in memory to \"hello, world!\", and then subsequently changing the state of the user's command line by emitting the message. As applications become larger state management becomes more complex. Over the years there have been many formal and informal approaches to solving the state problem, some examples are MVC, MVP, MVVM, Reactive, etc... the definitions get fuzzy at times and overlap, but they all have one thing in common - there's some sort of state that's maintained and changes to that state cause the application to change somehow. There are advantages and disadvantages to each approach, theories of code decoupling, event driven approaches, etc... Instead of discrete models, ApplicationState recogizes that the entire state of any application can be represented as a directed acyclic graph, where each node in the graph itentifies some part of the application and each leaf contains a discrete value. (Actually, nodes can be pointers to other nodes, but this is a convenience sugaring covered in advanced topics). Here's a simple example. Imagine an application that has a simple login form, a list of jobs, and a screen that can be used to view or edit a job. Here's a rough graph of what the overall state of that application might look like: In the above graph, the root node is \"app\", with a leaf called \"location\" and three child nodes, \"user\",\"screen\" and \"current_job\". Under the user node we have some leaves with values for things like username and access_token, under \"screen\" we have \"login\", \"job_list\" and \"job_view_edit\", etc... Using the above graph, any part of the application state can be represented using simple dotted notation. For example: 1 2 3 app . location app . screen . login . username app . user . access_token With application state, this is how you both set and retrieve values. At this point, it's natural to wonder what value this approach takes above a simple object that can be represented in any language. That brings us to the second part of the ApplicationState theory, which is responding to changes. Imagine that you need to validate that a username is valid after a user has entered it. Using ApplicationState, you'd add a listener to app.screen.login.username to be notified of the change, run the validation and mutate the UI in response. Followers of reactive application flow will be very familiar with this approach. One of the advantages to the ApplicationState approach, however, is the ability to add a listener to any node or leaf in the graph and to be notified of changes that have occurred in the subgraph. For example, maybe your application would like to keep a log of all changes that occurred when a job was being edited. Adding a listener to app.screen.job_view_edit would accomplish this trivially. The key architectural insight of ApplicationState is that ALL of your UI state is represented by the graph and can be instantly stored and retrieved. This is particularly useful, for example, in mobile applications where the application can be killed and restarted at any time, and the expectation is that state will be restored properly. In the BARE architecture repo , there is documentation about how ApplicationState can fit into an overall reactive architecture, though it should be noted that ApplicationState is not limited to BARE and can be used easily with React, React Native, etc... This is a brief summary of the ApplicationState theory, there is a lot more to it with tons of handy featues like: Previous state / undo Linked nodes Plugins for persistence, loading and additional functionality (see applicationstate-plugins-indexeddb for persistence and loading from IndexedDB in the browser) Notification control Future features will include: Isomorphism plugin - automatic sync to the server Merkle tree implementation for auto change detection/tree syncing Sub graph splitting and merging Cloud functions that respond to listeners/changes using AWS lambda, Google cloud functions, etc... Once the above features are implemented, many applications will be able to full implemented \"serverless\"","title":"Theory and Design"},{"location":"developing/","text":"Developing ApplicationState Currently a small group of developers is working on ApplicationState, but contributions from the wider community are welcomed. To get started check out the Github issues page for issues you can help out with. Getting Started with Development To get started with enhancing and developing on ApplicationState, just fork the repo in Github and clone from that. git clone https : // github . com /< your username >/ applicationstate . git We know many of you use yarn , and that's cool, but we use npm and prefer not to have yarn and npm package lock files in the repo. Fair warning, we will probably reject a pull request with yarn lock files present, so please use npm to install your dependencies. npm install Once you have added your new feature or bug fix, just submit a pull request through Github. However, take a few seconds to look at our requirements for contributions below. Hacking on ApplicationState To start directly working on ApplicationState and the default plugins you can use (and add to) our test suite. There are two choices for running tests. Running Tests in the Browser This is probably the best option for doing development on ApplicationState. It allows you to test in multiple browsers and does live updates when files change. Since this module is designed for the browser and designed to be run as a module, we use the webpack to create a testing environment run in the browser. This is accomplished through webpack-serve . Follow these steps to get it running. // install development dependencies npm install // run the webpack server and open the tests in default browser npm run dev // stop the server with ctrl - c Unlike most approaches to testing, the webpack-server keeps going. This enables you to update both the library and unit tests and see instant updates durring development. Of course the down side to that is you need to put in the momentous effort to ctrl-c to stop the server once you are done. Running Tests with Karma To enable us to run our tests with our CI/CD tool CircleCI we also use Karma . These tests are run in headless Chrome. This means that they can run in the command line so long as Chrome is installed. Running the tests is simple: npm test Contributions We encourage contributions, but ask that several things be in place. We would like signed commits. Sure, it's a bit heavy handed, but it helps us know that you are who you say you are. Documentation should come with code changes. The documentation should be updated for: New features. Updated features. Changes in the API. Potentially even with bug fixes. We will reject pull requests that don't have documentation updates and should. Documentation is annoying to write, but it makes the world better. Let's all do our part.","title":"Contributing"},{"location":"developing/#developing-applicationstate","text":"Currently a small group of developers is working on ApplicationState, but contributions from the wider community are welcomed. To get started check out the Github issues page for issues you can help out with.","title":"Developing ApplicationState"},{"location":"developing/#getting-started-with-development","text":"To get started with enhancing and developing on ApplicationState, just fork the repo in Github and clone from that. git clone https : // github . com /< your username >/ applicationstate . git We know many of you use yarn , and that's cool, but we use npm and prefer not to have yarn and npm package lock files in the repo. Fair warning, we will probably reject a pull request with yarn lock files present, so please use npm to install your dependencies. npm install Once you have added your new feature or bug fix, just submit a pull request through Github. However, take a few seconds to look at our requirements for contributions below.","title":"Getting Started with Development"},{"location":"developing/#hacking-on-applicationstate","text":"To start directly working on ApplicationState and the default plugins you can use (and add to) our test suite. There are two choices for running tests.","title":"Hacking on ApplicationState"},{"location":"developing/#running-tests-in-the-browser","text":"This is probably the best option for doing development on ApplicationState. It allows you to test in multiple browsers and does live updates when files change. Since this module is designed for the browser and designed to be run as a module, we use the webpack to create a testing environment run in the browser. This is accomplished through webpack-serve . Follow these steps to get it running. // install development dependencies npm install // run the webpack server and open the tests in default browser npm run dev // stop the server with ctrl - c Unlike most approaches to testing, the webpack-server keeps going. This enables you to update both the library and unit tests and see instant updates durring development. Of course the down side to that is you need to put in the momentous effort to ctrl-c to stop the server once you are done.","title":"Running Tests in the Browser"},{"location":"developing/#running-tests-with-karma","text":"To enable us to run our tests with our CI/CD tool CircleCI we also use Karma . These tests are run in headless Chrome. This means that they can run in the command line so long as Chrome is installed. Running the tests is simple: npm test","title":"Running Tests with Karma"},{"location":"developing/#contributions","text":"We encourage contributions, but ask that several things be in place. We would like signed commits. Sure, it's a bit heavy handed, but it helps us know that you are who you say you are. Documentation should come with code changes. The documentation should be updated for: New features. Updated features. Changes in the API. Potentially even with bug fixes. We will reject pull requests that don't have documentation updates and should. Documentation is annoying to write, but it makes the world better. Let's all do our part.","title":"Contributions"},{"location":"guide/","text":"","title":"Guide"},{"location":"references/","text":"Referencing and Dereferencing Syntax The means of getting and setting items within the state tree is accomplished via a dereferenced string. Here are some examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const example_1 = { a : 1 }; // key: 'a', value: '1' const example_2 = { a : { b : 1 } }; // key: 'a.b', value: '1' const example_3 = { a : [ { b : 1 } ] }; // key: 'a[0].b', value: '1' As you can see, the object hieracrhy is represented by variable names separated by either a . in the case of objects, or [#]. in the case of an array. These dereferenced strings can later be used to retrive a single value or a portion from within the state tree. Consider the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // the current state tree in ApplicationState const example_state = { a : 1 , b : \"2\" , c : { c1 : \"3\" , c2 : \"4\" } }; const c = ApplicationState . get ( \"c\" ); // we get { c1: \"3\", c2: \"4\" } const c1 = ApplicationState . get ( \"c.c1\" ); // we get \"3\" Practical Examples The reference system in ApplicationState is meant to follow the same syntax as object traversal in regular JavaScript. For instance in the following object: 1 2 3 4 5 6 7 const obj = { internal_obj : { item : \"abc123\" } }; ApplicationState . set ( \"app.obj\" , obj ); You would fetch the value assigned to item like this: 1 2 3 const app_state_value = ApplicationState . get ( \"app.obj.internal_obj.item\" ); const js_value = obj . internal_obj . item ; console . log ( app_state_value === js_value ); // prints true Note the similarity. In both cases the dot syntax provides a reference to the value. The same applies for array access. 1 2 3 4 5 6 7 8 9 const obj = { internal_array : [ \"abc123\" ] }; ApplicationState . set ( \"app.obj\" , obj ); const app_state_value = ApplicationState . get ( \"app.obj.internal_array[0]\" ); const js_value = obj . internal_array [ 0 ]; console . log ( app_state_value === js_value ); // prints true This works for all sorts of object types, including objects within arrays and arrays of arrays.","title":"Reference Strings"},{"location":"references/#referencing-and-dereferencing","text":"","title":"Referencing and Dereferencing"},{"location":"references/#syntax","text":"The means of getting and setting items within the state tree is accomplished via a dereferenced string. Here are some examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const example_1 = { a : 1 }; // key: 'a', value: '1' const example_2 = { a : { b : 1 } }; // key: 'a.b', value: '1' const example_3 = { a : [ { b : 1 } ] }; // key: 'a[0].b', value: '1' As you can see, the object hieracrhy is represented by variable names separated by either a . in the case of objects, or [#]. in the case of an array. These dereferenced strings can later be used to retrive a single value or a portion from within the state tree. Consider the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // the current state tree in ApplicationState const example_state = { a : 1 , b : \"2\" , c : { c1 : \"3\" , c2 : \"4\" } }; const c = ApplicationState . get ( \"c\" ); // we get { c1: \"3\", c2: \"4\" } const c1 = ApplicationState . get ( \"c.c1\" ); // we get \"3\"","title":"Syntax"},{"location":"references/#practical-examples","text":"The reference system in ApplicationState is meant to follow the same syntax as object traversal in regular JavaScript. For instance in the following object: 1 2 3 4 5 6 7 const obj = { internal_obj : { item : \"abc123\" } }; ApplicationState . set ( \"app.obj\" , obj ); You would fetch the value assigned to item like this: 1 2 3 const app_state_value = ApplicationState . get ( \"app.obj.internal_obj.item\" ); const js_value = obj . internal_obj . item ; console . log ( app_state_value === js_value ); // prints true Note the similarity. In both cases the dot syntax provides a reference to the value. The same applies for array access. 1 2 3 4 5 6 7 8 9 const obj = { internal_array : [ \"abc123\" ] }; ApplicationState . set ( \"app.obj\" , obj ); const app_state_value = ApplicationState . get ( \"app.obj.internal_array[0]\" ); const js_value = obj . internal_array [ 0 ]; console . log ( app_state_value === js_value ); // prints true This works for all sorts of object types, including objects within arrays and arrays of arrays.","title":"Practical Examples"},{"location":"release-notes/","text":"Release Notes 0.2.2 (Future release) Moved back to using a JavaScript class with static methods. Addition of CircleCI builds. Adding in MkDocs based documentation. Addition of Krama as a test target. Consolidation of default plugin builds into one build. Consolidation of default plugin tests into the main suite. 0.2.1 (7/30/2019) Fixed bug where rm did not use new walk function. Added notification tests. 0.2.0 (7/26/2019) New reference syntax and better array handling. IE11 compatibility for the main library and the new localStorage plugin. Decoupling of the main library from the plugins with an init function that injects the library in at runtime. Added the indexeddb and localStorage plugins to the main repo. More comprehensive tests.","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#022-future-release","text":"Moved back to using a JavaScript class with static methods. Addition of CircleCI builds. Adding in MkDocs based documentation. Addition of Krama as a test target. Consolidation of default plugin builds into one build. Consolidation of default plugin tests into the main suite.","title":"0.2.2 (Future release)"},{"location":"release-notes/#021-7302019","text":"Fixed bug where rm did not use new walk function. Added notification tests.","title":"0.2.1 (7/30/2019)"},{"location":"release-notes/#020-7262019","text":"New reference syntax and better array handling. IE11 compatibility for the main library and the new localStorage plugin. Decoupling of the main library from the plugins with an init function that injects the library in at runtime. Added the indexeddb and localStorage plugins to the main repo. More comprehensive tests.","title":"0.2.0 (7/26/2019)"},{"location":"start/","text":"Getting Started Instalation ApplicationState is available through npm . 1 npm install applicationstate Basics ApplicationState uses string versions of object references to do lookups in the state tree. In practical terms, that means however you would reference the object in plain old JavaScript is how it is referenced in the string. For a deeper understanding of how the reference strings work see documentation about references . The Importance of the \" app \" Root Node While you can set the root of each string reference to anything, ApplicationState hangs a lot of functionality around the root node being app . In particular the notification system will not fire for anything that is not under app . This is by design. For example, if you want to have something that is in ApplicationState but never triggers a notification (and thus most plugins won't pick it up), you can set it to cache.<your thing> or temp.<your thing> . When you set <your thing> , nothing but the set happens. If you set app.<your thing> , then a notification is fired and anything listening will respond. NOTE: It is best to set everything to app unless you know what you are doing. Getting and Setting ApplicationState is designed to store, retrive, and react to changes in state. For example: 1 2 3 ApplicationState . set ( \"app.something\" , \"something\" ); const something = ApplicationState . get ( \"app.something\" ); console . log ( something ); // prints \"something\"; This seems to act like a key-value store, but it's a bit more than that. For example: 1 2 3 ApplicationState . set ( \"app.something.nested\" , \"nested\" ); const something = ApplicationState . get ( \"app.something\" ); console . log ( something ); // prints { something: \"nested\" } As you can see, ApplicationState takes care of referencing and de-referencing the state graph. You can create a node in the graph using this method. Note that prior to this, neither something nor nested existed on the state graph until we set it. ApplicationState takes care of that for you. Lastly, you can connect two different parts of the state graph together using linking. 1 2 3 4 5 6 7 8 ApplicationState . set ( \"app.something.nested\" , \"nested\" ); ApplicationState . ln ( \"app.something.nested\" , \"app.a_link\" ); const something = ApplicationState . get ( \"app.a_link\" ); console . log ( something ); // prints \"nested\" ApplicationState . set ( \"app.a_link\" , \"changed\" ); const changed = ApplicationState . get ( \"app.something.nested\" ); console . log ( changed ); // prints \"changed\" Notice that in the above example, you can change the original or the linked item and the value for both is changed. It works a lot like the linux ln command. Reacting to Changes Keeping state is great, but many times you need a means to know when the state has changed. ApplicationState provides branch level notifications rather than just node level. This means that if anything changes within a child node of the state graph, all of it's parent elements will also get a notification, all the way up to the top level node. A perfect example of another system that works this way is the DOM. Here's an example of a few listeners. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ApplicationState . set ( \"app.parent.child_one\" , \"rebelious\" ); ApplicationState . set ( \"app.parent.child_two\" , \"obedient\" ); // Child level listener ApplicationState . listen ( \"app.parent.child_one\" , ( new_value , old_value ) => { console . log ( \"child level\" , new_value , old_value ); }); // Parent level listener ApplicationStaate . listen ( \"app.parent\" , ( new_value , old_value ) => { console . log ( \"parent_level\" , new_value , old_value ); }); ApplicationState . set ( \"app.parent.child_one\" , \"reformed\" ); // The parent level listener will print \"child_level\", \"reformed\", \"rebelious\" // The child level listener will print // \"parent_level\", // { child_one: \"reformed\", child_two: \"obedient\" }, // { child_one: \"rebelious\", child_two: \" obedient\" } The implications of being able to watch a branch rather than a node are significant. It allows an application to react to changes on multiple levels with relative ease. Removing listeners is a simple process, but requires you save the reference to the listener. 1 2 const listener_id = ApplicationState . listen ( \"app.something.nested\" , () => {}); ApplicationState . removeListener ( listener_id );","title":"Getting Started"},{"location":"start/#getting-started","text":"","title":"Getting Started"},{"location":"start/#instalation","text":"ApplicationState is available through npm . 1 npm install applicationstate","title":"Instalation"},{"location":"start/#basics","text":"ApplicationState uses string versions of object references to do lookups in the state tree. In practical terms, that means however you would reference the object in plain old JavaScript is how it is referenced in the string. For a deeper understanding of how the reference strings work see documentation about references .","title":"Basics"},{"location":"start/#the-importance-of-the-app-root-node","text":"While you can set the root of each string reference to anything, ApplicationState hangs a lot of functionality around the root node being app . In particular the notification system will not fire for anything that is not under app . This is by design. For example, if you want to have something that is in ApplicationState but never triggers a notification (and thus most plugins won't pick it up), you can set it to cache.<your thing> or temp.<your thing> . When you set <your thing> , nothing but the set happens. If you set app.<your thing> , then a notification is fired and anything listening will respond. NOTE: It is best to set everything to app unless you know what you are doing.","title":"The Importance of the \"app\" Root Node"},{"location":"start/#getting-and-setting","text":"ApplicationState is designed to store, retrive, and react to changes in state. For example: 1 2 3 ApplicationState . set ( \"app.something\" , \"something\" ); const something = ApplicationState . get ( \"app.something\" ); console . log ( something ); // prints \"something\"; This seems to act like a key-value store, but it's a bit more than that. For example: 1 2 3 ApplicationState . set ( \"app.something.nested\" , \"nested\" ); const something = ApplicationState . get ( \"app.something\" ); console . log ( something ); // prints { something: \"nested\" } As you can see, ApplicationState takes care of referencing and de-referencing the state graph. You can create a node in the graph using this method. Note that prior to this, neither something nor nested existed on the state graph until we set it. ApplicationState takes care of that for you. Lastly, you can connect two different parts of the state graph together using linking. 1 2 3 4 5 6 7 8 ApplicationState . set ( \"app.something.nested\" , \"nested\" ); ApplicationState . ln ( \"app.something.nested\" , \"app.a_link\" ); const something = ApplicationState . get ( \"app.a_link\" ); console . log ( something ); // prints \"nested\" ApplicationState . set ( \"app.a_link\" , \"changed\" ); const changed = ApplicationState . get ( \"app.something.nested\" ); console . log ( changed ); // prints \"changed\" Notice that in the above example, you can change the original or the linked item and the value for both is changed. It works a lot like the linux ln command.","title":"Getting and Setting"},{"location":"start/#reacting-to-changes","text":"Keeping state is great, but many times you need a means to know when the state has changed. ApplicationState provides branch level notifications rather than just node level. This means that if anything changes within a child node of the state graph, all of it's parent elements will also get a notification, all the way up to the top level node. A perfect example of another system that works this way is the DOM. Here's an example of a few listeners. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ApplicationState . set ( \"app.parent.child_one\" , \"rebelious\" ); ApplicationState . set ( \"app.parent.child_two\" , \"obedient\" ); // Child level listener ApplicationState . listen ( \"app.parent.child_one\" , ( new_value , old_value ) => { console . log ( \"child level\" , new_value , old_value ); }); // Parent level listener ApplicationStaate . listen ( \"app.parent\" , ( new_value , old_value ) => { console . log ( \"parent_level\" , new_value , old_value ); }); ApplicationState . set ( \"app.parent.child_one\" , \"reformed\" ); // The parent level listener will print \"child_level\", \"reformed\", \"rebelious\" // The child level listener will print // \"parent_level\", // { child_one: \"reformed\", child_two: \"obedient\" }, // { child_one: \"rebelious\", child_two: \" obedient\" } The implications of being able to watch a branch rather than a node are significant. It allows an application to react to changes on multiple levels with relative ease. Removing listeners is a simple process, but requires you save the reference to the listener. 1 2 const listener_id = ApplicationState . listen ( \"app.something.nested\" , () => {}); ApplicationState . removeListener ( listener_id );","title":"Reacting to Changes"},{"location":"plugins/default/","text":"Default Plugins At this time there are two storage plugins. One using Indexeddb, which is preferred for evergreen browsers. The other provides storage via localStorage, and is suitable for use with IE11. In both plugins it stores just the string reference and scalar values. Indexeddb Plugin The indexeddb plugin provides a robust storage option for loading and saving the state tree. It is the more performant of the two. Usage Initializing the plugin is simple, just do the following. import ApplicationState from \"applicationstate\" ; import { init } from \"applicationstate/plugins/indexeddb\" ; init ( ApplicationState , \"db_name\" ). then ( < start app here > ). catch ( < handle errors > ); The init function takes the ApplicationState singleton and the database name as an argument. We are passing in ApplicationState to support the future goal of application state supporting sub-trees in it's state. Reads and writes to the ApplicationState state tree are instant, but the writes to the actual indexeddb database are asynchronous. This means you can treat ApplicationState as synchronous in it's writes, without worrying about I/O blocking for the write to indexeddb. Note, this plugin uses the Dexie package to interact with indexeddb. Local Storage Plugin The local storage solution is overall less performant, but is fully supported by IE11. Usage Initializing the plugin is even simpler, just do the following. import ApplicationState from \"applicationstate\" ; import { init } from \"applicationstate/plugins/indexeddb\" ; init ( ApplicationState , \"db_name\" ); Note that this plugin does not return a promise. It is synchronous. This means that there is some I/O blocking involved. Large state trees are not recommended with this plugin.","title":"Default Plugins"},{"location":"plugins/default/#default-plugins","text":"At this time there are two storage plugins. One using Indexeddb, which is preferred for evergreen browsers. The other provides storage via localStorage, and is suitable for use with IE11. In both plugins it stores just the string reference and scalar values.","title":"Default Plugins"},{"location":"plugins/default/#indexeddb-plugin","text":"The indexeddb plugin provides a robust storage option for loading and saving the state tree. It is the more performant of the two.","title":"Indexeddb Plugin"},{"location":"plugins/default/#usage","text":"Initializing the plugin is simple, just do the following. import ApplicationState from \"applicationstate\" ; import { init } from \"applicationstate/plugins/indexeddb\" ; init ( ApplicationState , \"db_name\" ). then ( < start app here > ). catch ( < handle errors > ); The init function takes the ApplicationState singleton and the database name as an argument. We are passing in ApplicationState to support the future goal of application state supporting sub-trees in it's state. Reads and writes to the ApplicationState state tree are instant, but the writes to the actual indexeddb database are asynchronous. This means you can treat ApplicationState as synchronous in it's writes, without worrying about I/O blocking for the write to indexeddb. Note, this plugin uses the Dexie package to interact with indexeddb.","title":"Usage"},{"location":"plugins/default/#local-storage-plugin","text":"The local storage solution is overall less performant, but is fully supported by IE11.","title":"Local Storage Plugin"},{"location":"plugins/default/#usage_1","text":"Initializing the plugin is even simpler, just do the following. import ApplicationState from \"applicationstate\" ; import { init } from \"applicationstate/plugins/indexeddb\" ; init ( ApplicationState , \"db_name\" ); Note that this plugin does not return a promise. It is synchronous. This means that there is some I/O blocking involved. Large state trees are not recommended with this plugin.","title":"Usage"},{"location":"plugins/writing/","text":"Writing Plugins We are currently working out how best to write plugins ourselves, once we figure that out, we'll put it here.","title":"Writing Plugins"},{"location":"plugins/writing/#writing-plugins","text":"We are currently working out how best to write plugins ourselves, once we figure that out, we'll put it here.","title":"Writing Plugins"}]}